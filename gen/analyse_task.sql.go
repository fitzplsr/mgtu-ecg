// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: analyse_task.sql

package models

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAnalyseTask = `-- name: CreateAnalyseTask :one
INSERT INTO analyse_tasks (name, patient_id, filemeta_id, status)
VALUES ($1, $2, $3, $4)
RETURNING id, name, patient_id, filemeta_id, status, result, predict, created_at, updated_at
`

type CreateAnalyseTaskParams struct {
	Name       string
	PatientID  pgtype.Int4
	FilemetaID pgtype.Int4
	Status     int16
}

func (q *Queries) CreateAnalyseTask(ctx context.Context, arg CreateAnalyseTaskParams) (AnalyseTask, error) {
	row := q.db.QueryRow(ctx, createAnalyseTask,
		arg.Name,
		arg.PatientID,
		arg.FilemetaID,
		arg.Status,
	)
	var i AnalyseTask
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PatientID,
		&i.FilemetaID,
		&i.Status,
		&i.Result,
		&i.Predict,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAnalyseTasksByPatientID = `-- name: ListAnalyseTasksByPatientID :many
SELECT id, name, patient_id, filemeta_id, status, result, predict, created_at, updated_at
FROM analyse_tasks
WHERE patient_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListAnalyseTasksByPatientIDParams struct {
	PatientID pgtype.Int4
	Limit     int32
	Offset    int32
}

func (q *Queries) ListAnalyseTasksByPatientID(ctx context.Context, arg ListAnalyseTasksByPatientIDParams) ([]AnalyseTask, error) {
	rows, err := q.db.Query(ctx, listAnalyseTasksByPatientID, arg.PatientID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AnalyseTask
	for rows.Next() {
		var i AnalyseTask
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PatientID,
			&i.FilemetaID,
			&i.Status,
			&i.Result,
			&i.Predict,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const saveAnalyseTaskResult = `-- name: SaveAnalyseTaskResult :one
UPDATE analyse_tasks
SET result  = $1,
    predict = $2,
    status  = $3
WHERE id = $4
RETURNING id, name, patient_id, filemeta_id, status, result, predict, created_at, updated_at
`

type SaveAnalyseTaskResultParams struct {
	Result  int16
	Predict pgtype.Text
	Status  int16
	ID      int32
}

func (q *Queries) SaveAnalyseTaskResult(ctx context.Context, arg SaveAnalyseTaskResultParams) (AnalyseTask, error) {
	row := q.db.QueryRow(ctx, saveAnalyseTaskResult,
		arg.Result,
		arg.Predict,
		arg.Status,
		arg.ID,
	)
	var i AnalyseTask
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PatientID,
		&i.FilemetaID,
		&i.Status,
		&i.Result,
		&i.Predict,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const searchAnalyseTasks = `-- name: SearchAnalyseTasks :many

SELECT id, name, patient_id, filemeta_id, status, result, predict, created_at, updated_at
FROM analyse_tasks
WHERE name LIKE '%' || $1 || '%'
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type SearchAnalyseTasksParams struct {
	Column1 pgtype.Text
	Limit   int32
	Offset  int32
}

// -- name: ListAnalyseTasks :many
// SELECT *
// FROM analyse_tasks
// ORDER BY created_at DESC
// LIMIT $1 OFFSET $2;
func (q *Queries) SearchAnalyseTasks(ctx context.Context, arg SearchAnalyseTasksParams) ([]AnalyseTask, error) {
	rows, err := q.db.Query(ctx, searchAnalyseTasks, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AnalyseTask
	for rows.Next() {
		var i AnalyseTask
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.PatientID,
			&i.FilemetaID,
			&i.Status,
			&i.Result,
			&i.Predict,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setAnalyseTaskStatus = `-- name: SetAnalyseTaskStatus :one
UPDATE analyse_tasks
SET status  = $1
WHERE id = $2
RETURNING id, name, patient_id, filemeta_id, status, result, predict, created_at, updated_at
`

type SetAnalyseTaskStatusParams struct {
	Status int16
	ID     int32
}

func (q *Queries) SetAnalyseTaskStatus(ctx context.Context, arg SetAnalyseTaskStatusParams) (AnalyseTask, error) {
	row := q.db.QueryRow(ctx, setAnalyseTaskStatus, arg.Status, arg.ID)
	var i AnalyseTask
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.PatientID,
		&i.FilemetaID,
		&i.Status,
		&i.Result,
		&i.Predict,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
